<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bus Tracker – OTL Oradea (All Lines)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html,body { height:100%; margin:0; padding:0; font-family: system-ui, Arial; }
  #map { width:100%; height:100%; }

  /* pizza-slice marker */
  .arrow-outer {
    width:40px; height:40px;
    display:flex; justify-content:center; align-items:flex-end;
    clip-path: polygon(50% 0%, 90% 80%, 80% 100%, 20% 100%, 10% 80%);
    position:relative;
    box-sizing: border-box;
  }

  /* circle fallback when still initial */
  .arrow-outer.circle {
    clip-path: circle(40% at 50% 50%);
    align-items:center; justify-content:center;
  }

  .arrow-inner { width:30px; height:30px; transform: rotate(0deg); pointer-events:none; display:block; }

  /* left toolbar toggles */
  #bus-toggle {
    position:absolute; top:10px; left:10px; z-index:1100;
    display:flex; flex-direction:column; gap:6px;
    max-height: calc(100vh - 20px); overflow:auto; padding-right:4px;
  }
  .toggle-btn {
    width:38px; height:38px; border-radius:50%;
    background:white; border:2px solid #222;
    display:flex; align-items:center; justify-content:center;
    padding:0; cursor:pointer;
    opacity:0.45; /* default off */
  }
  .toggle-btn[aria-checked="true"] { opacity:1; }
  .toggle-btn img { width:32px; height:32px; display:block; }

  @media (max-width:420px){
    .arrow-outer { width:34px; height:34px; }
    .arrow-inner { width:26px; height:26px; }
    .toggle-btn img { width:26px; height:26px; }
  }
</style>
</head>
<body>
<div id="map" aria-label="Map"></div>
<div id="bus-toggle" aria-label="Bus line toggles"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ---------- Config ---------- */
const LINES = [
  "10","11","12","13","14","15","16T","17","18","19","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","41",
  "511","512","513","514","515","516","517","531","611","612","721","722","ROHU"
];

const ICON_BASE = "https://www.otlra.ro/upload/www.otlra.ro/lines/";
const API_TEMPLATE = "https://www.otlra.ro/templates/cassiopeia/php/get_vehicles_xml.php?line=";
const CORS_PROXY = "https://corsproxy.io/?";
const UPDATE_INTERVAL = 10000;
const MIN_MOVE = 0.00001;

/* ---------- Map setup ---------- */
const map = L.map('map', { zoomControl: false }).setView([47.07,21.92], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '© OpenStreetMap contributors'
}).addTo(map);

/* ---------- State ---------- */
let currentMarkers = [];
const previousPositions = {};
const previousRotations = {};
const initialFlag = {};
const visibleLines = {};
const lineIconColor = {};
const iconLoadCache = {};

LINES.forEach(l => visibleLines[l] = false); // **all off initially**

/* ---------- Helpers ---------- */
function iconUrlForLine(line){ return ICON_BASE + encodeURIComponent(line) + ".png"; }

async function sampleIconColor(line, defaultColor="#FF6F00"){
  if(iconLoadCache[line]) return iconLoadCache[line];
  const p = (async () => {
    try {
      const img = new Image(); img.crossOrigin="Anonymous";
      img.src = CORS_PROXY + iconUrlForLine(line);
      await new Promise((res,rej)=>{ img.onload=res; img.onerror=()=>rej(new Error("Icon load failed")); });
      const canvas = document.createElement('canvas'); canvas.width=16; canvas.height=16;
      const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0,16,16);
      const data = ctx.getImageData(0,0,16,16).data;
      let r=0,g=0,b=0,count=0;
      for(let i=0;i<data.length;i+=4){ if(data[i+3]<50) continue; r+=data[i]; g+=data[i+1]; b+=data[i+2]; count++; }
      if(count===0) return defaultColor;
      r=Math.round(r/count); g=Math.round(g/count); b=Math.round(b/count);
      return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
    } catch(e){ console.warn("Color sample failed",line,e); return defaultColor; }
  })();
  iconLoadCache[line]=p; return p;
}

/* ---------- Toggle toolbar ---------- */
const toggleContainer = document.getElementById('bus-toggle');
LINES.forEach(line=>{
  const btn=document.createElement('button');
  btn.className="toggle-btn"; btn.dataset.line=line; btn.setAttribute('aria-checked','false');
  btn.title="Toggle linia "+line;

  const img=document.createElement('img'); img.src=iconUrlForLine(line); img.alt="Linia "+line;
  btn.appendChild(img);

  btn.addEventListener('click', async ()=>{
    visibleLines[line]=!visibleLines[line];
    btn.setAttribute('aria-checked', visibleLines[line]?'true':'false');

    if(!visibleLines[line]){
      currentMarkers=currentMarkers.filter(m=>{ if(m.busLine===line){ map.removeLayer(m); return false; } return true; });
    } else {
      await sampleIconColor(line).catch(()=>{});
      updateLine(line).catch(e=>console.error(e));
    }
  });

  toggleContainer.appendChild(btn);
});

/* ---------- Render helpers ---------- */
function createDivIconHtml(line, iconUrl, rotation, isCircle, bgColor){
  const styleBG = bgColor ? `background:${bgColor};` : '';
  const styleRotate = !isCircle ? `transform: rotate(${rotation}deg);` : '';
  const innerRotate = !isCircle ? `transform: rotate(${-rotation}deg);` : '';
  return `<div class="arrow-outer ${isCircle?'circle':''}" style="${styleBG};${styleRotate}">
            <img class="arrow-inner" src="${iconUrl}" style="${innerRotate}" alt="${line}"/>
          </div>`;
}

async function updateLine(line){
  try{
    const res=await fetch(CORS_PROXY+API_TEMPLATE+encodeURIComponent(line));
    if(!res.ok) throw new Error("HTTP "+res.status);
    const vehicles=await res.json();
    const colorPromise = sampleIconColor(line);

    for(const v of vehicles){
      const lat=parseFloat(v.lat), lng=parseFloat(v.lng);
      if(Number.isNaN(lat)||Number.isNaN(lng)) continue;
      const vid=v.id||(line+"-"+Math.random().toString(36).slice(2,10));
      let rotation = previousRotations[vid]||0;
      if(!(vid in initialFlag)) initialFlag[vid]=true;

      if(previousPositions[vid]){
        const prev=previousPositions[vid];
        const dx=lng-prev.lng, dy=lat-prev.lat, dist=Math.sqrt(dx*dx+dy*dy);
        if(dist>=MIN_MOVE){ rotation=(-Math.atan2(dy,dx)*(180/Math.PI)+90); previousRotations[vid]=rotation; initialFlag[vid]=false; }
      }
      previousPositions[vid]={lat,lng};
      const isCircle=!!initialFlag[vid];
      const iconUrl=iconUrlForLine(line);
      const sampledColor=await colorPromise.catch(()=>"#FF6F00");
      const html=createDivIconHtml(line, iconUrl, rotation, isCircle, sampledColor);
      const divIcon=L.divIcon({className:'', html, iconSize:[36,36], iconAnchor:[18,18], popupAnchor:[0,-18]});
      const marker=L.marker([lat,lng],{icon:divIcon}).bindPopup(v.title||("Linia "+line));
      marker.busLine=line; marker.vehicleId=vid;
      if(visibleLines[line]) marker.addTo(map);
      currentMarkers.push(marker);
    }
  }catch(e){ console.error("updateLine error",line,e); }
}

async function updateAllVisible(){
  try{
    currentMarkers.forEach(m=>map.removeLayer(m));
    currentMarkers=[];
    for(const line of LINES){
      if(!visibleLines[line]) continue;
      sampleIconColor(line).catch(()=>{});
      await updateLine(line);
    }
  }catch(e){ console.error("updateAllVisible error",e); }
}
// Show user location
map.locate({setView: true, maxZoom: 16, watch: true});

let myMarker = null;
map.on('locationfound', (e) => {
  const latlng = e.latlng;
  if (!myMarker) {
    myMarker = L.circleMarker(latlng, {
      radius: 8,
      color: '#1976D2',
      fillColor: '#1976D2',
      fillOpacity: 0.8
    }).addTo(map).bindPopup("You are here");
  } else {
    myMarker.setLatLng(latlng);
  }
});

map.on('locationerror', (err) => {
  console.warn("Location not available:", err.message);
});

/* ---------- Start ---------- */
updateAllVisible();
setInterval(updateAllVisible, UPDATE_INTERVAL);
</script>
</body>
</html>
